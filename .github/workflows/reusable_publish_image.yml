# Reusable workflow for building and publishing container images with security best practices
# This workflow implements a 4-stage secure build pipeline:
# 1. Local build + 2. Secret & vulnerability scanning + 3. Push (Buildx emits SBOM & provenance) + 4. Signing & verification
# Note: Repository secret scanning and containerfile linting are handled by reusable_ci.yml (MegaLinter)

name: Reusable Build and Publish Image

on:
  workflow_call:
    inputs:
      allowed_identity_regex:
        description: 'Regex for Cosign certificate identity (optional, defaults to org-level)'
        required: false
        type: string
      component_name:
        description: 'Component name (e.g., compass, beacon-distro)'
        required: true
        type: string
      containerfile_path:
        description: 'Containerfile path relative to repo root (e.g., compass/images/Containerfile.compass)'
        required: true
        type: string
      context_path:
        description: 'Build context path (e.g., ./compass)'
        required: true
        type: string
      dry_run:
        description: 'Run security checks without pushing or signing'
        required: false
        type: boolean
        default: false
      force_rebuild:
        description: 'Force rebuild without cache'
        required: false
        type: boolean
        default: false
      image_name:
        description: 'Full image name (e.g., ghcr.io/complytime/complybeacon-compass)'
        required: true
        type: string

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ inputs.image_name }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    permissions:
      contents: read
      packages: none
      id-token: none        # for OIDC (attestations / cosign keyless)
      security-events: none # for the Trivy SARIF step
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Container metadata
        id: meta
        uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051 # v5.10.0
        with:
          images: ${{ inputs.image_name }}
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}},enable=${{ !startsWith(github.ref, 'refs/tags/v0.') }}
            type=ref,event=branch,suffix=-{{sha}}
            type=sha,prefix=sha-
            type=schedule,pattern={{date 'YYYYMMDD-HHmmss'}},prefix=scheduled-
            type=raw,value=latest,enable={{is_default_branch}}
          flavor: |
            latest=auto
          labels: |
            org.opencontainers.image.title=${{ inputs.component_name }}
            org.opencontainers.image.description=ComplyBeacon ${{ inputs.component_name }} service
            org.opencontainers.image.vendor=ComplyTime

      - name: Log in to GHCR
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@c7c53464625b32c7a7e944ae62b3e17d2b600130 # v3.7.0

      - name: Set up Container Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1

      # STAGE 1: Build locally first (don't push yet!)
      - name: Build and load to Container (Stage 1 - Local Build)
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
        with:
          context: ${{ inputs.context_path }}
          file: ${{ inputs.containerfile_path }}
          load: true
          push: false
          platforms: linux/amd64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=${{ inputs.component_name }}
          cache-to: type=gha,mode=max,scope=${{ inputs.component_name }}
          sbom: false
          provenance: false

      # STAGE 2: Security scanning (secrets + vulnerabilities)
      - name: Scan image for secrets (Stage 2 - Security)
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8 # 0.33.1
        with:
          image-ref: ${{ inputs.image_name }}:sha-${{ github.sha }}
          exit-code: 1
          scanners: secret
          severity: HIGH,CRITICAL,MEDIUM
          format: table

      - name: Scan image for vulnerabilities (Stage 2 - Security)
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8 # 0.33.1
        with:
          image-ref: ${{ inputs.image_name }}:sha-${{ github.sha }}
          format: sarif
          output: trivy-results.sarif
          vuln-type: 'os,library'
          severity: HIGH,CRITICAL
          ignore-unfixed: true

      - name: Upload vulnerability scan results
        uses: github/codeql-action/upload-sarif@cf1bb45a277cb3c205638b2cd5c984db1c46a412 # v4.31.7
        with:
          sarif_file: trivy-results.sarif
          category: ${{ inputs.component_name }}-vulnerabilities

      # STAGE 3: Build and push (emits SBOM & provenance via Buildx; uses cache)
      - name: Build and push (Stage 3 - Final Push)
        id: build
        if: ${{ !inputs.dry_run }}
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
        with:
          context: ${{ inputs.context_path }}
          file: ${{ inputs.containerfile_path }}
          push: true
          platforms: linux/amd64,linux/arm64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=${{ inputs.component_name }}
          cache-to: type=gha,mode=max,scope=${{ inputs.component_name }}
          sbom: true
          provenance: mode=max
          no-cache: ${{ inputs.force_rebuild }}

      - name: Export digest
        id: digest
        if: ${{ !inputs.dry_run }}
        run: echo "digest=${{ steps.build.outputs.digest }}" >> "$GITHUB_OUTPUT"

      - name: Generate SBOM (CycloneDX) for local image (dry run)
        if: ${{ inputs.dry_run }}
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8 # 0.33.1
        with:
          image-ref: ${{ inputs.image_name }}:sha-${{ github.sha }}
          format: cyclonedx
          output: sbom.cdx.json

      # STAGE 4: Signing and verification (keyless via Cosign)
      - name: Install Cosign (Stage 4 - Signing)
        if: ${{ !inputs.dry_run }}
        uses: sigstore/cosign-installer@faadad0cce49287aee09b3a48701e75088a2c6ad # v4.0.0

      - name: Sign image (Stage 4 - Signing)
        if: ${{ !inputs.dry_run }}
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          IMAGE="${{ inputs.image_name }}@${{ steps.digest.outputs.digest }}"
          echo "Signing: $IMAGE"
          cosign sign --yes "$IMAGE"

      - name: Verify signature (Stage 4 - Verification)
        if: ${{ !inputs.dry_run }}
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          IMAGE="${{ inputs.image_name }}@${{ steps.digest.outputs.digest }}"
          IDENTITY_REGEX="${{ inputs.allowed_identity_regex }}"
          if [ -z "$IDENTITY_REGEX" ]; then IDENTITY_REGEX="https://github.com/${{ github.repository_owner }}/.*"; fi
          echo " Verifying: $IMAGE"
          cosign verify "$IMAGE" \
            --certificate-identity-regexp="$IDENTITY_REGEX" \
            --certificate-oidc-issuer=https://token.actions.githubusercontent.com
          echo "Signature verified!"

      - name: Verify SLSA provenance attestation (Stage 4 - Verification)
        if: ${{ !inputs.dry_run }}
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          IMAGE="${{ inputs.image_name }}@${{ steps.digest.outputs.digest }}"
          IDENTITY_REGEX="${{ inputs.allowed_identity_regex }}"
          if [ -z "$IDENTITY_REGEX" ]; then IDENTITY_REGEX="https://github.com/${{ github.repository_owner }}/.*"; fi
          echo "ðŸ” Verifying provenance attestation for: $IMAGE"
          cosign verify-attestation "$IMAGE" \
            --type slsaprovenance \
            --certificate-identity-regexp="$IDENTITY_REGEX" \
            --certificate-oidc-issuer=https://token.actions.githubusercontent.com
          echo "Provenance attestation verified!"

      - name: Verify SBOM attestation (Stage 4 - Verification)
        if: ${{ !inputs.dry_run }}
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          IMAGE="${{ inputs.image_name }}@${{ steps.digest.outputs.digest }}"
          IDENTITY_REGEX="${{ inputs.allowed_identity_regex }}"
          if [ -z "$IDENTITY_REGEX" ]; then IDENTITY_REGEX="https://github.com/${{ github.repository_owner }}/.*"; fi
          echo "ðŸ” Verifying SBOM attestation for: $IMAGE"
          cosign verify-attestation "$IMAGE" \
            --type spdx \
            --certificate-identity-regexp="$IDENTITY_REGEX" \
            --certificate-oidc-issuer=https://token.actions.githubusercontent.com
          echo "SBOM attestation verified!"

      # Summary
      - name: Published image summary
        if: ${{ !inputs.dry_run }}
        run: |
          cat >> "$GITHUB_STEP_SUMMARY" <<EOF
          ## Successfully Published: ${{ inputs.component_name }}

          **Image:** ${{ inputs.image_name }}
          **Digest:** ${{ steps.digest.outputs.digest }}

          ### Tags
          \`\`\`
          $(echo "${{ steps.meta.outputs.tags }}" | tr ',' '\n')
          \`\`\`

          ### Security Checks Passed âœ“
          - Secret scanning
          - Vulnerability scanning
          - SBOM generated and verified
          - Provenance verified
          - Image signed and verified
          EOF
