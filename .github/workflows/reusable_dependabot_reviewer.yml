name: Reusable Dependabot Reviewer

# --------------------------------------------------------------------------
# This workflow only runs when explicitly called by another workflow.
# --------------------------------------------------------------------------
on:
  workflow_call:
    outputs:
      risk_level:
        description: "Risk level assessment based on semantic version"
        value: "${{ jobs.dependabot_review.outputs.risk_level }}"
      updates_count:
        description: "Rough number of projects that already adopted this dependency"
        value: "${{ jobs.dependabot_review.outputs.updates_count }}"

# This workflow is passive so ensure the minimal permissions even if the
# inherited token is more lenient.
permissions:
  contents: read
  issues: none
  pull-requests: none

jobs:
  dependabot_review:
    name: Dependabot Review
    if: github.actor == 'dependabot[bot]'
    runs-on: ubuntu-latest

    outputs:
      risk_level: "${{ steps.classify_risk.outputs.risk_level }}"
      updates_count: "${{ steps.check_popularity.outputs.updates_count }}"

    steps:
      - name: Checkout Repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          repository: "${{ github.event.repository.full_name }}"
          fetch-depth: 2

      - name: Get Dependency Information
        shell: bash
        env:
          DEPENDABOT_SHA: "${{ github.event.pull_request.head.sha }}"
        run: |
          # Use 'git log' specifically on the Dependabot commit SHA to get its subject.
          # This command works regardless of which commit SHA was checked out locally.
          COMMIT_SUBJECT="$(git log -1 --format=%s "$DEPENDABOT_SHA")"
          echo "Dependabot Commit Subject: $COMMIT_SUBJECT"

          # Extract dependency name from commit title
          dep_name="$(echo "$COMMIT_SUBJECT" | sed -E 's/.*[Bb]ump ([^ ]+) .*/\1/')"
          if [[ -n "$dep_name" ]]; then
            echo "Dependency Name: $dep_name"
            echo "DEP_NAME=$dep_name" >> "$GITHUB_ENV"
          fi

          if grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' <<< "$COMMIT_SUBJECT"; then
            # Extract two semantic version numbers (e.g., 1.2.3)
            mapfile -t versions < <(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' <<< "$COMMIT_SUBJECT")
          else
            # In some cases, the dependency name and version are not in the commit title.
            # So, we need to extract the versions from the commit description.
            COMMIT_DESCRIPTION="$(git log -1 --format=%B "$DEPENDABOT_SHA" | grep -i Bumps)"
            mapfile -t versions < <(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' <<< "$COMMIT_DESCRIPTION")
          fi

          if [[ "${#versions[@]}" -eq 2 ]]; then
            echo "Versions: ${versions[0]} -> ${versions[1]}"
            echo "FROM_VERSION=${versions[0]}" >> "$GITHUB_ENV"
            echo "TO_VERSION=${versions[1]}" >> "$GITHUB_ENV"
          fi

          # Extract dependency name and version together in case of GitHub Actions
          # The title is not always standardized, so we need to extract the name and version from the file changes.
          dep_name_and_version="$(grep -rhoE "uses:[[:space:]']*$dep_name.*@[^\s#]+" .github/workflows/ | sed 's/uses:[[:space:]]*//' | tail -n1 || echo '')"
          echo "Dependency Name and Version: $dep_name_and_version"
          echo "DEP_NAME_AND_VERSION=$dep_name_and_version" >> "$GITHUB_ENV"

      - name: Classify Risk Based on Semantic Version
        id: classify_risk
        shell: bash
        run: |
          risk="high"  # Default risk level

          if [[ -z "${{ env.FROM_VERSION }}" || -z "${{ env.TO_VERSION }}" ]]; then
            echo "No clear versioning detected."
            echo "Risk level: $risk"
            echo "risk_level=$risk" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          FROM_VER_MAJOR=$(echo "${{ env.FROM_VERSION }}" | cut -d. -f1)
          FROM_VER_MINOR=$(echo "${{ env.FROM_VERSION }}" | cut -d. -f2)
          TO_VER_MAJOR=$(echo "${{ env.TO_VERSION }}" | cut -d. -f1)
          TO_VER_MINOR=$(echo "${{ env.TO_VERSION }}" | cut -d. -f2)

          if [[ "$FROM_VER_MAJOR" -eq "$TO_VER_MAJOR" && "$FROM_VER_MINOR" -eq "$TO_VER_MINOR" ]]; then
            echo "Patch update detected."
            risk="low"
          elif [[ "$FROM_VER_MAJOR" -eq "$TO_VER_MAJOR" && "$FROM_VER_MINOR" -lt "$TO_VER_MINOR" ]]; then
            echo "Minor update detected."
            risk="medium"
          else
            echo "Major update detected. Likely includes breaking changes. Requires manual review."
          fi

          echo "Risk level: $risk"
          echo "risk_level=$risk" >> "$GITHUB_OUTPUT"

      - name: Get Changed Files
        id: changed_files
        uses: tj-actions/changed-files@e0021407031f5be11a464abee9a0776171c79891 # v47.0.1

      - name: Detect Ecosystem
        id: detect_ecosystem
        if: steps.changed_files.outputs.any_changed == 'true'
        env:
          ALL_CHANGED_FILES: "${{ steps.changed_files.outputs.all_changed_files }}"
        run: |
          if [[ $ALL_CHANGED_FILES =~ (^|[[:space:]])go\.mod($|[[:space:]]) ]]; then
            eco="go"
          elif [[ $ALL_CHANGED_FILES =~ (^|[[:space:]])requirements\.txt($|[[:space:]]) || \
                  $ALL_CHANGED_FILES =~ (^|[[:space:]])pyproject\.toml($|[[:space:]]) || \
                  $ALL_CHANGED_FILES =~ (^|[[:space:]])setup\.cfg($|[[:space:]]) || \
                  $ALL_CHANGED_FILES =~ (^|[[:space:]])poetry\.lock($|[[:space:]]) ]]; then
            eco="python"
          elif [[ $ALL_CHANGED_FILES == *".github/workflows/"* || \
                  $ALL_CHANGED_FILES == *".github/actions/"* ]]; then
            eco="github_actions"
          else
            echo "No dependency changes detected. Unknown ecosystem."
            eco="unknown"
          fi

          echo "Detected ecosystem: $eco"
          echo "ecosystem=$eco" >> "$GITHUB_OUTPUT"

      - name: Search GitHub for Dependency Usage
        id: check_popularity
        env:
          GH_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
        run: |
          dep="${{ env.DEP_NAME }}"
          ver="${{ env.TO_VERSION }}"
          name_and_ver="${{ env.DEP_NAME_AND_VERSION }}"
          eco="${{ steps.detect_ecosystem.outputs.ecosystem }}"

          case "$eco" in
            python)
              # There are many different ways to declare Python dependencies making it hard
              # to bring consistent results. So, skipping Python dependency count for now.
              echo "Queries for Python dependencies are not consistent enough. Skipping"
              echo "updates_count=0" >> "$GITHUB_OUTPUT"
              exit 0
              ;;
            go)
              query="${dep} v${ver} filename:go.mod"
              ;;
            github_actions)
              if [[ -n "${name_and_ver}" ]]; then
                pattern="${name_and_ver}"
              else
                pattern="${dep}@v${ver}"
              fi
              query="${pattern} path:.github/workflows/"
              ;;
            *)
              echo "Unknown ecosystem, skipping search."
              echo "updates_count=0" >> "$GITHUB_OUTPUT"
              exit 0
              ;;
          esac

          echo "Searching GitHub with following query:"
          echo " - gh search code \"$query\" --json repository --limit 25"

          # Run search with retry logic
          for i in {1..3}; do
            result="$(gh search code "$query" --json repository --limit 25 2>/dev/null)" && break
            echo "Search failed (attempt $i), retrying..."
            sleep "$((i * 5))"
          done

          if [[ -z "$result" ]]; then
            echo "updates_count=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          repo_list="$(jq -r '.[].repository.nameWithOwner' <<<"$result" | sort -u)"
          count=$(wc -w <<<"$repo_list")

          echo "Repository Count: $count"
          echo "Repository List: $repo_list"

          {
            echo "updates_count=$count"
            echo "repo_list<<EOF"
            echo "$repo_list"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
