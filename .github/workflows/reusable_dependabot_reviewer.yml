name: Reusable Dependabot Reviewer

# --------------------------------------------------------------------------
# This workflow only runs when explicitly called by another workflow.
# --------------------------------------------------------------------------
on:
  workflow_call:
    outputs:
      risk_level:
        description: "Risk level assessment based on semantic version"
        value: "${{ jobs.dependabot_review.outputs.risk_level }}"
      updates_count:
        description: "Rough number of projects that already adopted this dependency"
        value: "${{ jobs.dependabot_review.outputs.updates_count }}"

# This workflow is passive so ensure the minimal permissions even if the
# inherited token is more lenient.
permissions:
  contents: read
  issues: none
  pull-requests: none

jobs:
  dependabot_review:
    name: Dependabot Review
    if: github.actor == 'dependabot[bot]'
    runs-on: ubuntu-latest

    outputs:
      risk_level: "${{ steps.classify_risk.outputs.risk_level }}"
      updates_count: "${{ steps.check_popularity.outputs.updates_count }}"

    steps:
      - name: Checkout Repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          repository: "${{ github.event.repository.full_name }}"
          fetch-depth: 2

      - name: Get Dependency Information
        shell: bash
        env:
          DEPENDABOT_SHA: "${{ github.event.pull_request.head.sha }}"
        run: |
          # Use 'git log' specifically on the Dependabot commit SHA to get its subject.
          # This command works regardless of which commit SHA was checked out locally.
          COMMIT_SUBJECT="$(git log -1 --format=%s "$DEPENDABOT_SHA")"
          echo "Dependabot Commit Subject: $COMMIT_SUBJECT"

          # Extract dependency name from commit title
          dep_name="$(echo "$COMMIT_SUBJECT" | sed -E 's/.*Bump ([^ ]+) .*/\1/')"
          if [[ -n "$dep_name" ]]; then
            echo "Dependency Name: $dep_name"
            echo "DEP_NAME=$dep_name" >> "$GITHUB_ENV"
          fi

          # Extract two semantic version numbers (e.g., 1.2.3)
          mapfile -t versions < <(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' <<< "$COMMIT_SUBJECT")

          if [[ "${#versions[@]}" -eq 2 ]]; then
            echo "Versions: ${versions[0]} -> ${versions[1]}"
            echo "FROM_VERSION=${versions[0]}" >> "$GITHUB_ENV"
            echo "TO_VERSION=${versions[1]}" >> "$GITHUB_ENV"
          fi

          # Extract dependency pinned version in case of GitHub Actions
          git show "$DEPENDABOT_SHA" --format= --unified=0 --no-prefix -- .github/workflows/
          pinned_version="$(
            grep -rEo "$dep_name@[0-9a-f]{40}" .github/workflows/ \
              | awk -F'@' '{ print $2}' \
              | tail -n1 || echo ''
          )"
          if [[ -n "$pinned_version" ]]; then
            echo "Dependency Commit Hash: $pinned_version"
            echo "PINNED_VERSION=$pinned_version" >> "$GITHUB_ENV"
          fi

      - name: Classify Risk Based on Semantic Version
        id: classify_risk
        shell: bash
        run: |
          if [[ -z "${{ env.FROM_VERSION }}" || -z "${{ env.TO_VERSION }}" ]]; then
            echo "risk_level=high" >> "$GITHUB_OUTPUT"
            echo "::notice::No clear versioning detected. Defaulting to high risk."
            exit 0
          fi

          FROM_VER_MAJOR=$(echo "${{ env.FROM_VERSION }}" | cut -d. -f1)
          FROM_VER_MINOR=$(echo "${{ env.FROM_VERSION }}" | cut -d. -f2)
          TO_VER_MAJOR=$(echo "${{ env.TO_VERSION }}" | cut -d. -f1)
          TO_VER_MINOR=$(echo "${{ env.TO_VERSION }}" | cut -d. -f2)

          if [[ "$FROM_VER_MAJOR" -eq "$TO_VER_MAJOR" && "$FROM_VER_MINOR" -eq "$TO_VER_MINOR" ]]; then
            echo "Patch update detected."
            echo "risk_level=low" >> "$GITHUB_OUTPUT"
          elif [[ "$FROM_VER_MAJOR" -eq "$TO_VER_MAJOR" && "$FROM_VER_MINOR" -lt "$TO_VER_MINOR" ]]; then
            echo "Minor update detected."
            echo "risk_level=medium" >> "$GITHUB_OUTPUT"
          else
            echo "Major update detected. Likely includes breaking changes. Requires manual review."
            echo "risk_level=high" >> "$GITHUB_OUTPUT"
          fi

      - name: Get Changed Files
        id: changed_files
        uses: tj-actions/changed-files@24d32ffd492484c1d75e0c0b894501ddb9d30d62 # v47.0.0

      - name: Detect Ecosystem
        id: detect_ecosystem
        if: steps.changed_files.outputs.any_changed == 'true'
        env:
          ALL_CHANGED_FILES: "${{ steps.changed_files.outputs.all_changed_files }}"
          DEP_NAME: "${{ env.DEP_NAME }}"
        run: |
          eco="unknown" # Initialize
          if [[ "$DEP_NAME" == *"/"* ]]; then
            eco="github_actions"
          elif grep -q "go.mod" "$ALL_CHANGED_FILES"; then
            eco="go"
          elif grep -q -E "requirements\.txt|pyproject\.toml|setup\.cfg" "$ALL_CHANGED_FILES"; then
            eco="python"
          # Fallback for other GitHub Actions changes
          # (e.g., action updates that don't follow the owner/repo format, or if dependency name check failed)
          elif grep -q -E "\.ya?ml" "$ALL_CHANGED_FILES"; then
            eco="github_actions"
          fi

          echo "Detected ecosystem: $eco"
          echo "ecosystem=$eco" >> "$GITHUB_OUTPUT"

      - name: Search GitHub for Dependency Usage
        id: check_popularity
        env:
          GH_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
        run: |
          dep="${{ env.DEP_NAME }}"
          ver="${{ env.TO_VERSION }}"
          ver_sha="${{ env.PINNED_VERSION }}"
          eco="${{ steps.detect_ecosystem.outputs.ecosystem }}"

          case "$eco" in
            python)
              # There are many different ways to declare Python dependencies making it hard
              # to bring consistent results. So, skipping Python dependency count for now.
              echo "Queries for Python dependencies are not consistent enough. Skipping"
              echo "updates_count=0" >> "$GITHUB_OUTPUT"
              exit 0
              ;;
            go)
              query="${dep} v${ver} filename:go.mod"
              ;;
            github_actions)
              if [[ -n "${ver_sha}" ]]; then
                ver="${ver_sha}"
              else
                ver="v${ver}"
              fi
              query="${dep}@${ver} path:.github/workflows/"
              ;;
            *)
              echo "Unknown ecosystem, skipping search."
              echo "updates_count=0" >> "$GITHUB_OUTPUT"
              exit 0
              ;;
          esac

          echo "Searching GitHub with following query:"
          echo " - $query"

          # Run search with retry logic
          for i in {1..3}; do
            result="$(gh search code "$query" --json repository --limit 25 2>/dev/null)" && break
            echo "Search failed (attempt $i), retrying..."
            sleep "$((i * 5))"
          done

          if [[ -z "$result" ]]; then
            echo "updates_count=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          repo_list="$(jq -r '.[].repository.nameWithOwner' <<<"$result" | sort -u)"
          count=$(wc -w <<<"$repo_list")

          {
            echo "updates_count=$count"
            echo "repo_list<<EOF"
            echo "$repo_list"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
