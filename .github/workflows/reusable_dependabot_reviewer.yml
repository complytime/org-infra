name: Reusable Dependabot Reviewer

# --------------------------------------------------------------------------
# This workflow is only run when explicitly called by another workflow.
# --------------------------------------------------------------------------
on:
  workflow_call:
    outputs:
      risk_level:
        description: "Risk level assessment based on semantic version"
        value: "${{ jobs.dependabot_review.outputs.risk_level }}"
      updates_count:
        description: "Rough number of projects that already adopted this dependency"
        value: "${{ jobs.dependabot_review.outputs.updates_count }}"

# This workflow is passive so ensure the minimal permissions even if the
# inherited token is more lenient.
permissions:
  contents: read
  issues: none
  pull-requests: none

jobs:
  dependabot_review:
    if: github.actor == 'dependabot[bot]'
    runs-on: ubuntu-latest

    outputs:
      risk_level: "${{ steps.classify_risk.outputs.risk_level }}"
      updates_count: "${{ steps.check_popularity.outputs.updates_count }}"

    steps:
      - name: Checkout Repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          repository: "${{ github.event.repository.full_name }}"
          fetch-depth: 2

      - name: Get Dependency Information
        shell: bash
        env:
          DEPENDABOT_SHA: "${{ github.event.pull_request.head.sha }}"
        run: |
          # Use 'git log' specifically on the Dependabot commit SHA to get its subject.
          # This command works regardless of which commit SHA was checked out locally.
          COMMIT_SUBJECT="$(git log -1 --format=%s "$DEPENDABOT_SHA")"
          echo "Dependabot Commit Subject: $COMMIT_SUBJECT"

          # Extract dependency name from commit title
          dep_name="$(echo "$COMMIT_SUBJECT" | sed -E 's/.*Bump ([^ ]+) .*/\1/')"
          if [[ -n "$dep_name" ]]; then
            echo "Dependency Name: $dep_name"
            echo "DEP_NAME=$dep_name" >> "$GITHUB_ENV"
          fi

          # Extract two semantic version numbers (e.g., 1.2.3)
          mapfile -t versions < <(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' <<< "$COMMIT_SUBJECT")

          if [[ "${#versions[@]}" -eq 2 ]]; then
            echo "Versions: ${versions[0]} -> ${versions[1]}"
            echo "FROM_VERSION=${versions[0]}" >> "$GITHUB_ENV"
            echo "TO_VERSION=${versions[1]}" >> "$GITHUB_ENV"
          fi

      - name: Classify Risk Based on Semantic Version
        id: classify_risk
        shell: bash
        run: |
          if [[ -z "${{ env.FROM_VERSION }}" || -z "${{ env.TO_VERSION }}" ]]; then
            echo "risk_level=high" >> "$GITHUB_OUTPUT"
            echo "::notice::No clear versioning detected. Defaulting to high risk."
            exit 0
          fi

          FROM_VER_MAJOR=$(echo "${{ env.FROM_VERSION }}" | cut -d. -f1)
          FROM_VER_MINOR=$(echo "${{ env.FROM_VERSION }}" | cut -d. -f2)
          TO_VER_MAJOR=$(echo "${{ env.TO_VERSION }}" | cut -d. -f1)
          TO_VER_MINOR=$(echo "${{ env.TO_VERSION }}" | cut -d. -f2)

          if [[ "$FROM_VER_MAJOR" -eq "$TO_VER_MAJOR" && "$FROM_VER_MINOR" -eq "$TO_VER_MINOR" ]]; then
            echo "Patch update detected."
            echo "risk_level=low" >> "$GITHUB_OUTPUT"
          elif [[ "$FROM_VER_MAJOR" -eq "$TO_VER_MAJOR" && "$FROM_VER_MINOR" -lt "$TO_VER_MINOR" ]]; then
            echo "Minor update detected."
            echo "risk_level=medium" >> "$GITHUB_OUTPUT"
          else
            echo "Major update detected. Likely includes breaking changes. Requires manual review."
            echo "risk_level=high" >> "$GITHUB_OUTPUT"
          fi

      - name: Get Changed Files
        id: changed_files
        uses: tj-actions/changed-files@24d32ffd492484c1d75e0c0b894501ddb9d30d62 # v47.0.0

      - name: Detect Ecosystem
        id: detect_ecosystem
        if: steps.changed_files.outputs.any_changed == 'true'
        env:
          ALL_CHANGED_FILES: "${{ steps.changed_files.outputs.all_changed_files }}"
          DEP_NAME: "${{ env.DEP_NAME }}"
        run: |
          eco="unknown" # Initialize
          if [[ "$DEP_NAME" == *"/"* ]]; then
            eco="github_actions"
          elif grep -q "go.mod" "$ALL_CHANGED_FILES"; then
            eco="go"
          elif grep -q -E "requirements\.txt|pyproject\.toml|setup\.cfg" "$ALL_CHANGED_FILES"; then
            eco="python"
          # Fallback for other GitHub Actions changes
          # (e.g., action updates that don't follow the owner/repo format, or if dependency name check failed)
          elif grep -q -E "\.ya?ml" "$ALL_CHANGED_FILES"; then
            eco="github_actions"
          fi

          echo "Detected ecosystem: $eco"
          echo "ecosystem=$eco" >> "$GITHUB_OUTPUT"

      - name: Search GitHub for Dependency Usage
        id: check_popularity
        env:
          GH_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
        run: |
          dep="${{ env.DEP_NAME }}"
          ver="${{ env.TO_VERSION }}"
          eco="${{ steps.detect_ecosystem.outputs.ecosystem }}"

          case "$eco" in
            python)
              # Combined query: (reqs.txt pattern) OR (pyproject.toml pattern)
              query="((${dep}==${ver} filename:requirements.txt) OR (\"${dep} = \\\"${ver}\\\"\" filename:pyproject.toml))"
              ;;
            go)
              # Combined query: ("dep $ver" pattern) OR ("dep v$ver" pattern) + file filter
              query="filename:go.mod ((\"${dep} ${ver}\") OR (\"${dep} v${ver}\"))"
              ;;
            github_actions)
              # Combined query: (uses: pattern) OR (direct ref pattern) + path filter
              query="path:.github/workflows/ ((uses: ${dep}@${ver}) OR (${dep}@${ver}))"
              ;;
            *)
              echo "Unknown ecosystem, skipping search."
              echo "updates_count=0" >> "$GITHUB_OUTPUT"
              exit 0
              ;;
          esac

          echo "Searching GitHub with combined pattern:"
          echo " - $query"

          result=$(gh search code "$query" --json repository --limit 25 | jq '.[].repository.fullName' | sort -u)
          count=$(echo "$result" | grep -v '^$' -c)

          echo "updates_count=$count" >> "$GITHUB_OUTPUT"
          echo "List of repositories using this dependency version: $result" >> "$GITHUB_OUTPUT"
